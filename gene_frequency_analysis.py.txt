Python script to process BLAST results (outfmt 6) and export summary statistics to Excel.

This script generates an Excel file with, for each mitochondrial gene (qseqid):
- Mitochondrial gene size (estimated as max(qend))
- Number of alignments against the nuclear genome
- Minimum, mean, and maximum alignment length
- Minimum, mean, and maximum % gene coverage per alignment (length / gene_size * 100)
- Maximum effective % gene coverage (union of merged query intervals)
- Minimum, mean, and maximum percent identity (pident)
"""

import pandas as pd


def merge_intervals(intervals):
    """
    Merge overlapping intervals.
    Each interval is a tuple: (start, end), inclusive.
    """
    intervals = sorted(intervals, key=lambda x: x[0])
    merged = []

    for start, end in intervals:
        if not merged or merged[-1][1] < start - 1:
            merged.append((start, end))
        else:
            merged[-1] = (merged[-1][0], max(merged[-1][1], end))

    return merged


# Column names for BLAST outfmt 6
columns = [
    "qseqid",    # Query ID (mitochondrial gene)
    "sseqid",    # Subject ID (nuclear genome)
    "pident",    # Percent identity
    "length",    # Alignment length
    "mismatch",
    "gapopen",
    "qstart",    # Query start
    "qend",      # Query end
    "sstart",
    "send",
    "evalue",
    "bitscore"
]

# Read BLAST tabular output
df = pd.read_csv(
    "blastn_nuclear_vs_mitocondrial_genes_e0.001.out",
    sep="\t",
    names=columns
)

results = []

# Group by mitochondrial gene (qseqid)
for gene, group in df.groupby("qseqid"):
    # Estimate gene size as the maximum qend for that gene
    gene_size = group["qend"].max()

    # Number of alignments against nuclear genome
    n_alignments = group.shape[0]

    # Alignment length statistics
    aln_len_mean = group["length"].mean()
    aln_len_min = group["length"].min()
    aln_len_max = group["length"].max()

    # Per-alignment gene coverage (%)
    coverage_per_aln = (group["length"] / gene_size) * 100
    coverage_min = coverage_per_aln.min()
    coverage_mean = coverage_per_aln.mean()
    coverage_max = coverage_per_aln.max()

    # Build (qstart, qend) intervals for each alignment (inclusive)
    intervals = []
    for _, row in group.iterrows():
        start = min(row["qstart"], row["qend"])
        end = max(row["qstart"], row["qend"])
        intervals.append((start, end))

    # Merge overlapping query intervals to compute effective coverage
    merged = merge_intervals(intervals)

    covered_length = sum(end - start + 1 for start, end in merged)
    covered_length_effective = min(covered_length, gene_size)  # cap at gene size
    effective_coverage = (covered_length_effective / gene_size) * 100

    # Percent identity statistics
    pid_mean = group["pident"].mean()
    pid_min = group["pident"].min()
    pid_max = group["pident"].max()

    results.append({
        "Mitochondrial gene": gene,
        "Mitochondrial gene size": gene_size,
        "Number of alignments vs nuclear genome": n_alignments,
        "Mean alignment length": aln_len_mean,
        "Min alignment length": aln_len_min,
        "Max alignment length": aln_len_max,
        "Min % of gene covered per alignment": coverage_min,
        "Mean % of gene covered per alignment": coverage_mean,
        "Max % of gene covered per alignment": coverage_max,
        "Max effective % gene coverage (merged intervals)": effective_coverage,
        "Mean % identity": pid_mean,
        "Min % identity": pid_min,
        "Max % identity": pid_max
    })

# Export results to Excel
df_results = pd.DataFrame(results)
df_results.to_excel("results.xlsx", index=False)
print("Archivo Excel generado exitosamente: resultados.xlsx")


